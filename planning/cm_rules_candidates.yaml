rules:
  - rule_id: "ui-gotcha-001"
    category: "ui-gotchas"
    rule_text: "When calling ChildBuilder.setOffset on UIBox children, always call ui.box.RenewAlignment afterward to recompute layout."
    doc_id: "pattern:ui.uibox_alignment.renew_after_offset"
    test_ref: "test_ui_patterns.lua::ui.uibox_alignment.renew_after_offset"
    quirks_anchor: "renewalignment-after-setoffset"
    status: "unverified"
    severity: "error"
    tags: ["ui", "layout", "ordering"]
    rationale: "Offsets update InheritedProperties only; layout does not reflow until RenewAlignment."
    example_good: |
      ChildBuilder.setOffset(child, 100, 50)
      ui.box.RenewAlignment(registry, container)
    example_bad: |
      ChildBuilder.setOffset(child, 100, 50) -- missing RenewAlignment
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-002"
    category: "ui-gotchas"
    rule_text: "After ui.box.ReplaceChildren, call ui.box.RenewAlignment to reflow the new child layout."
    doc_id: "pattern:ui.uibox_alignment.renew_after_replacechildren"
    test_ref: "test_ui_patterns.lua::ui.uibox_alignment.renew_after_replacechildren"
    quirks_anchor: "renewalignment-after-replacechildren"
    status: "unverified"
    severity: "error"
    tags: ["ui", "layout", "ordering"]
    rationale: "ReplaceChildren invalidates cached alignment for the UIBox tree."
    example_good: |
      ui.box.ReplaceChildren(container, newChildren)
      ui.box.RenewAlignment(registry, container)
    example_bad: |
      ui.box.ReplaceChildren(container, newChildren) -- missing RenewAlignment
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-003"
    category: "ui-gotchas"
    rule_text: "After spawning a UIBox, add the default state tag using ui.box.AddStateTagToUIBox."
    doc_id: "pattern:ui.statetag.add_after_spawn"
    test_ref: "test_ui_patterns.lua::ui.statetag.add_after_spawn"
    quirks_anchor: "addstatetagto-uibox-after-spawn"
    status: "unverified"
    severity: "warn"
    tags: ["ui", "state"]
    rationale: "State tags are not assigned automatically on spawn."
    example_good: |
      ui.box.AddStateTagToUIBox(registry, entity, "default_state")
    example_bad: |
      -- no state tags added after spawn
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-004"
    category: "ui-gotchas"
    rule_text: "After ui.box.ReplaceChildren, reapply state tags with ui.box.AddStateTagToUIBox."
    doc_id: "pattern:ui.statetag.add_after_replacechildren"
    test_ref: "test_ui_patterns.lua::ui.statetag.add_after_replacechildren"
    quirks_anchor: "addstatetagto-uibox-after-replacechildren"
    status: "unverified"
    severity: "error"
    tags: ["ui", "state", "ordering"]
    rationale: "ReplaceChildren clears state tags from the UIBox tree."
    example_good: |
      ui.box.ReplaceChildren(container, newChildren)
      ui.box.AddStateTagToUIBox(registry, container, "default_state")
    example_bad: |
      ui.box.ReplaceChildren(container, newChildren) -- missing AddStateTagToUIBox
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-005"
    category: "ui-gotchas"
    rule_text: "If UI state tags stop responding, reapply tags after any UI tree rebuild."
    doc_id: "pattern:ui.statetag.persistence_check"
    test_ref: "test_ui_patterns.lua::ui.statetag.persistence_check"
    quirks_anchor: "state-tag-persistence-check"
    status: "unverified"
    severity: "warn"
    tags: ["ui", "state"]
    rationale: "Rebuilds can silently clear state tags."
    example_good: |
      ui.box.AddStateTagToUIBox(registry, panel, "default_state")
    example_bad: |
      -- rely on previous tags after ReplaceChildren
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-006"
    category: "ui-gotchas"
    rule_text: "When moving a UI panel, update both Transform and UIBoxComponent.uiRoot, then RenewAlignment."
    doc_id: "pattern:ui.visibility.move_transform_and_uiroot"
    test_ref: "test_ui_patterns.lua::ui.visibility.move_transform_and_uiroot"
    quirks_anchor: "move-both-transform-and-uiboxcomponent-uiroot"
    status: "unverified"
    severity: "error"
    tags: ["ui", "visibility"]
    rationale: "Children align to uiRoot, not the panel Transform alone."
    example_good: |
      t.actualX, t.actualY = x, y
      root_t.actualX, root_t.actualY = x, y
      ui.box.RenewAlignment(registry, entity)
    example_bad: |
      t.actualX, t.actualY = x, y -- uiRoot not moved
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-007"
    category: "ui-gotchas"
    rule_text: "Moving only the panel Transform does not move UIBox children; always move uiRoot too."
    doc_id: "pattern:ui.visibility.transform_only_fails"
    test_ref: "test_ui_patterns.lua::ui.visibility.transform_only_fails"
    quirks_anchor: "transform-only-move-fails"
    status: "unverified"
    severity: "error"
    tags: ["ui", "visibility"]
    rationale: "uiRoot remains at old coordinates, so children stay behind."
    example_good: |
      root_t.actualX, root_t.actualY = x, y
    example_bad: |
      t.actualX, t.actualY = x, y -- children stay at old position
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-008"
    category: "ui-gotchas"
    rule_text: "Clickable UI elements must include ScreenSpaceCollisionMarker."
    doc_id: "pattern:ui.collision.screenspace_marker_required"
    test_ref: "test_ui_patterns.lua::ui.collision.screenspace_marker_required"
    quirks_anchor: "marker-required-for-clicks"
    status: "unverified"
    severity: "error"
    tags: ["ui", "input"]
    rationale: "Input system ignores entities without the marker."
    example_good: |
      registry:emplace(entity, ScreenSpaceCollisionMarker {})
    example_bad: |
      -- no ScreenSpaceCollisionMarker
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-009"
    category: "ui-gotchas"
    rule_text: "After UI rebuilds, ensure ScreenSpaceCollisionMarker is still attached for click detection."
    doc_id: "pattern:ui.collision.click_detection_with_marker"
    test_ref: "test_ui_patterns.lua::ui.collision.click_detection_with_marker"
    quirks_anchor: "click-detection-with-marker"
    status: "unverified"
    severity: "warn"
    tags: ["ui", "input"]
    rationale: "Markers can be lost when rebuilding UI trees."
    example_good: |
      registry:emplace(button, ScreenSpaceCollisionMarker {})
    example_bad: |
      ui.box.ReplaceChildren(container, children) -- marker lost
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-010"
    category: "ui-gotchas"
    rule_text: "Without ScreenSpaceCollisionMarker, clicks should be treated as no-ops."
    doc_id: "pattern:ui.collision.click_fails_without_marker"
    test_ref: "test_ui_patterns.lua::ui.collision.click_fails_without_marker"
    quirks_anchor: "click-fails-without-marker"
    status: "unverified"
    severity: "warn"
    tags: ["ui", "input"]
    rationale: "No marker means no screen-space collision."
    example_good: |
      -- expect no click callbacks without marker
    example_bad: |
      -- assume click will work without marker
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-011"
    category: "ui-gotchas"
    rule_text: "Grid teardown must clear itemRegistry, call grid:destroy(), and dsl.cleanupGrid."
    doc_id: "pattern:ui.grid.cleanup_all_three_registries"
    test_ref: "test_ui_patterns.lua::ui.grid.cleanup_all_three_registries"
    quirks_anchor: "cleanup-all-three-registries"
    status: "unverified"
    severity: "error"
    tags: ["ui", "grid", "cleanup"]
    rationale: "Partial cleanup leaves orphaned items or stale state."
    example_good: |
      itemRegistry = {}
      grid:destroy()
      dsl.cleanupGrid(registry)
    example_bad: |
      grid:destroy() -- registry cleanup skipped
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-012"
    category: "ui-gotchas"
    rule_text: "Destroying a grid without clearing itemRegistry leaves stale items."
    doc_id: "pattern:ui.grid.cleanup_partial_fails"
    test_ref: "test_ui_patterns.lua::ui.grid.cleanup_partial_fails"
    quirks_anchor: "partial-cleanup-fails"
    status: "unverified"
    severity: "warn"
    tags: ["ui", "grid", "cleanup"]
    rationale: "itemRegistry still points to destroyed grid slots."
    example_good: |
      itemRegistry = {}
    example_bad: |
      grid:destroy() -- itemRegistry still populated
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-013"
    category: "ui-gotchas"
    rule_text: "HUD elements must use DrawCommandSpace.Screen to stay fixed."
    doc_id: "pattern:ui.drawspace.screen_fixed_hud"
    test_ref: "test_ui_patterns.lua::ui.drawspace.screen_fixed_hud"
    quirks_anchor: "screen-draw-space-stays-fixed"
    status: "unverified"
    severity: "error"
    tags: ["ui", "rendering"]
    rationale: "World draw space follows camera movement."
    example_good: |
      command_buffer.queueDraw(layers.ui, fn, z, layer.DrawCommandSpace.Screen)
    example_bad: |
      command_buffer.queueDraw(layers.ui, fn, z, layer.DrawCommandSpace.World)
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-014"
    category: "ui-gotchas"
    rule_text: "DrawCommandSpace.World will make UI elements follow camera movement."
    doc_id: "pattern:ui.drawspace.world_follows_camera"
    test_ref: "test_ui_patterns.lua::ui.drawspace.world_follows_camera"
    quirks_anchor: "world-draw-space-follows-camera"
    status: "unverified"
    severity: "warn"
    tags: ["ui", "rendering"]
    rationale: "World space coordinates are camera-relative."
    example_good: |
      -- use World only for diegetic UI
    example_bad: |
      -- using World for HUD
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-015"
    category: "ui-gotchas"
    rule_text: "Never add ObjectAttachedToUITag to draggable UI elements."
    doc_id: "pattern:ui.attached.never_on_draggables"
    test_ref: "test_ui_patterns.lua::ui.attached.never_on_draggables"
    quirks_anchor: "never-use-objectattachedto-uitag-on-draggables"
    status: "unverified"
    severity: "error"
    tags: ["ui", "drag"]
    rationale: "The tag forces attachment behavior that conflicts with drag logic."
    example_good: |
      -- leave draggables without ObjectAttachedToUITag
    example_bad: |
      registry:emplace(card, ObjectAttachedToUITag {})
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-016"
    category: "ui-gotchas"
    rule_text: "ObjectAttachedToUITag is safe for non-draggable attachments that should follow a parent."
    doc_id: "pattern:ui.attached.correct_usage"
    test_ref: "test_ui_patterns.lua::ui.attached.correct_usage"
    quirks_anchor: "objectattachedto-uitag-correct-usage"
    status: "unverified"
    severity: "info"
    tags: ["ui", "attachment"]
    rationale: "Static attachments can use the tag without conflicting drag behavior."
    example_good: |
      registry:emplace(badge, ObjectAttachedToUITag {})
    example_bad: |
      -- missing tag for static attachment
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-017"
    category: "ui-gotchas"
    rule_text: "ChildBuilder.setOffset should be followed by RenewAlignment even for small offsets."
    doc_id: "pattern:ui.childbuilder.setoffset_requires_renew"
    test_ref: "test_ui_patterns.lua::ui.uibox_alignment.renew_after_offset"
    quirks_anchor: "setoffset-requires-renewalignment"
    status: "unverified"
    severity: "warn"
    tags: ["ui", "layout"]
    rationale: "Layout caches do not update on offset change alone."
    example_good: |
      ChildBuilder.setOffset(child, 5, 5)
      ui.box.RenewAlignment(registry, container)
    example_bad: |
      ChildBuilder.setOffset(child, 5, 5) -- no RenewAlignment
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-018"
    category: "ui-gotchas"
    rule_text: "ReplaceChildren on nested UI trees requires reapplying state tags on the new root."
    doc_id: "pattern:ui.statetag.add_after_replacechildren"
    test_ref: "test_ui_patterns.lua::ui.statetag.add_after_replacechildren"
    quirks_anchor: "addstatetagto-uibox-after-replacechildren"
    status: "unverified"
    severity: "warn"
    tags: ["ui", "state"]
    rationale: "Nested trees inherit state tags from the root UIBox."
    example_good: |
      ui.box.AddStateTagToUIBox(registry, root, "default_state")
    example_bad: |
      ui.box.ReplaceChildren(root, children) -- missing tag reapply
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-019"
    category: "ui-gotchas"
    rule_text: "Slot decorations on sprite panels must be scaled with ui_scale.SPRITE_SCALE."
    doc_id: "pattern:ui.slot_decorations.sprite_panel_scaling"
    test_ref: "manual"
    quirks_anchor: "slot-decorations-and-sprite-panels"
    status: "unverified"
    severity: "info"
    tags: ["ui", "decorations"]
    rationale: "Decorations are applied in sprite-space and must use sprite scale."
    example_good: |
      gridConfig.slotDecorations = { { sprite = "decor.png" } }
    example_bad: |
      -- decorations applied without sprite scaling
    last_verified_commit: "pending"

  - rule_id: "ui-gotcha-020"
    category: "ui-gotchas"
    rule_text: "UIBox creation should add default state tags immediately after spawn."
    doc_id: "pattern:ui.uibox_creation.basic"
    test_ref: "test_ui_patterns.lua::ui.statetag.add_after_spawn"
    quirks_anchor: "uibox-creation-and-configuration"
    status: "unverified"
    severity: "warn"
    tags: ["ui", "state"]
    rationale: "UIBoxes do not auto-assign state tags on spawn."
    example_good: |
      local box = dsl.spawn(pos, def)
      ui.box.AddStateTagToUIBox(registry, box, "default_state")
    example_bad: |
      local box = dsl.spawn(pos, def) -- missing state tag
    last_verified_commit: "pending"

  # =====================================================
  # ECS GOTCHAS (from Phase 4B)
  # =====================================================

  - rule_id: "ecs-gotcha-001"
    category: "ecs-gotchas"
    rule_text: "When attaching scripts, always assign data before attach_ecs because attach-time hooks read fields immediately."
    doc_id: "pattern:ecs.attach_ecs.assign_before_attach"
    test_ref: "test_entity_lifecycle.lua::ecs.attach_ecs.assign_before_attach"
    quirks_anchor: "ecs-attach-ecs-timing"
    status: "verified"
    severity: "error"
    tags: ["ecs", "lifecycle", "ordering"]
    rationale: "Attach-time hooks (run_custom_func, addStateTag, etc.) read fields immediately. Late data means hooks see nil."
    example_good: |
      local script = EntityType {}
      script.data = { value = 42 }    -- Assign FIRST
      script:attach_ecs { ... }       -- Attach LAST
    example_bad: |
      local script = EntityType {}
      script:attach_ecs { ... }       -- Attach first
      script.data = { value = 42 }    -- DATA LOST!
    last_verified_commit: "pending"

  - rule_id: "ecs-gotcha-002"
    category: "ecs-gotchas"
    rule_text: "Never store gameplay data on GameObject components; use the script table instead to keep data discoverable."
    doc_id: "pattern:ecs.gameobject.no_data_storage"
    test_ref: "test_entity_lifecycle.lua::ecs.gameobject.no_data_storage"
    quirks_anchor: "ecs-gameobject-restrictions"
    status: "verified"
    severity: "error"
    tags: ["ecs", "component", "storage"]
    rationale: "GameObject is a component wrapper. Script data must live on the script table to be discoverable via safe_script_get/getScriptTableFromEntityID."
    example_good: |
      local script = safe_script_get(entity)
      script.myData = { hp = 10 }
    example_bad: |
      local gameObj = component_cache.get(entity, GameObject)
      gameObj.myData = {}  -- WRONG: bypasses script table system
    last_verified_commit: "pending"

  - rule_id: "ecs-gotcha-003"
    category: "ecs-gotchas"
    rule_text: "Keep LuaJIT functions under ~200 locals by grouping values in tables to avoid crashes."
    doc_id: "pattern:ecs.luajit.200_local_limit"
    test_ref: "test_entity_lifecycle.lua::ecs.luajit.200_local_limit"
    quirks_anchor: "ecs-luajit-locals"
    status: "verified"
    severity: "error"
    tags: ["luajit", "performance", "limits"]
    rationale: "LuaJIT crashes at runtime if a function has more than 200 locals."
    example_good: |
      local sounds = { footsteps = { ... } }
    example_bad: |
      local sound1, sound2, sound3 = ...  -- 197 more = CRASH
    last_verified_commit: "pending"

  - rule_id: "ecs-gotcha-004"
    category: "ecs-gotchas"
    rule_text: "Invalidate component_cache entries on destroy or component removal to prevent stale data."
    doc_id: "pattern:ecs.cache.invalidation"
    test_ref: "test_entity_lifecycle.lua::ecs.cache.invalidation"
    quirks_anchor: "ecs-component-cache"
    status: "verified"
    severity: "error"
    tags: ["ecs", "cache", "cleanup"]
    rationale: "Cached lookups are fast but must be invalidated on destroy/remove to avoid stale data."
    example_good: |
      component_cache.invalidate(eid, Transform)
    example_bad: |
      -- Forget to invalidate after destroy; cache returns stale data
    last_verified_commit: "pending"

  - rule_id: "ecs-gotcha-005"
    category: "ecs-gotchas"
    rule_text: "Attach-time callbacks (run_custom_func/addStateTag) require data assigned before attach_ecs."
    doc_id: "pattern:ecs.attach_ecs.assign_before_attach"
    test_ref: "test_entity_lifecycle.lua::ecs.attach_ecs.assign_before_attach"
    quirks_anchor: "ecs-attach-ecs-timing"
    status: "verified"
    severity: "error"
    tags: ["ecs", "lifecycle", "callbacks"]
    rationale: "Callbacks run during attach_ecs and need data already present."
    example_good: |
      script.data = { state = "ready" }
      script:attach_ecs { run_custom_func = setup }
    example_bad: |
      script:attach_ecs { run_custom_func = setup }  -- setup sees nil data
    last_verified_commit: "pending"

  # =====================================================
  # ECS PATTERNS (from Phase 4B)
  # =====================================================

  - rule_id: "ecs-pattern-001"
    category: "ecs-patterns"
    rule_text: "Use Node.quick or EntityBuilder.validated to guarantee data assignment occurs before attach_ecs."
    doc_id: "pattern:ecs.attach_ecs.assign_before_attach"
    test_ref: "test_entity_lifecycle.lua::ecs.attach_ecs.assign_before_attach"
    quirks_anchor: "ecs-attach-ecs-timing"
    status: "verified"
    severity: "info"
    tags: ["ecs", "pattern", "builder"]
    rationale: "Builder patterns enforce correct ordering automatically."
    example_good: |
      EntityBuilder.validated({data = {value = 42}}):attach()
    example_bad: |
      -- Manual ordering is error-prone
    last_verified_commit: "pending"

  - rule_id: "ecs-pattern-002"
    category: "ecs-patterns"
    rule_text: "Store entity state on the script table so safe_script_get and script_field can retrieve it reliably."
    doc_id: "pattern:ecs.gameobject.script_table_usage"
    test_ref: "test_entity_lifecycle.lua::ecs.gameobject.script_table_usage"
    quirks_anchor: "ecs-gameobject-restrictions"
    status: "verified"
    severity: "info"
    tags: ["ecs", "pattern", "storage"]
    rationale: "Script table is the canonical location for entity state."
    example_good: |
      script.hp = 100
      script.data.inventory = {}
    example_bad: |
      -- Storing elsewhere makes data undiscoverable
    last_verified_commit: "pending"

  - rule_id: "ecs-pattern-003"
    category: "ecs-patterns"
    rule_text: "Validate entity ids with ensure_entity before component or script access to avoid invalid lookups."
    doc_id: "pattern:ecs.validate.ensure_entity_valid"
    test_ref: "test_entity_lifecycle.lua::ecs.validate.ensure_entity_valid"
    quirks_anchor: "ecs-validation"
    status: "verified"
    severity: "warn"
    tags: ["ecs", "validation", "safety"]
    rationale: "Accessing invalid entities causes crashes or undefined behavior."
    example_good: |
      if ensure_entity(eid) then
          local t = component_cache.get(eid, Transform)
      end
    example_bad: |
      local t = component_cache.get(eid, Transform)  -- might be invalid
    last_verified_commit: "pending"

  - rule_id: "ecs-pattern-004"
    category: "ecs-patterns"
    rule_text: "Use ensure_scripted_entity when you require a ScriptComponent to avoid nil script tables."
    doc_id: "pattern:ecs.validate.ensure_scripted_entity_valid"
    test_ref: "test_entity_lifecycle.lua::ecs.validate.ensure_scripted_entity_valid"
    quirks_anchor: "ecs-validation"
    status: "verified"
    severity: "warn"
    tags: ["ecs", "validation", "script"]
    rationale: "ensure_scripted_entity confirms both validity AND script presence."
    example_good: |
      if ensure_scripted_entity(eid) then
          local script = safe_script_get(eid)
      end
    example_bad: |
      local script = safe_script_get(eid)  -- might return nil
    last_verified_commit: "pending"

  - rule_id: "ecs-pattern-005"
    category: "ecs-patterns"
    rule_text: "Use safe_script_get for script access and guard nil to prevent crashes on destroyed entities."
    doc_id: "pattern:ecs.access.safe_script_get_valid"
    test_ref: "test_entity_lifecycle.lua::ecs.access.safe_script_get_valid"
    quirks_anchor: "ecs-script-access"
    status: "verified"
    severity: "info"
    tags: ["ecs", "access", "safety"]
    rationale: "safe_script_get returns nil on invalid/missing script instead of crashing."
    example_good: |
      local script = safe_script_get(eid)
      if script then ... end
    example_bad: |
      local script = getScriptTableFromEntityID(eid)  -- crashes on invalid
    last_verified_commit: "pending"

  - rule_id: "ecs-pattern-006"
    category: "ecs-patterns"
    rule_text: "Prefer script_field(eid, field, default) to avoid nil checks and express defaults explicitly."
    doc_id: "pattern:ecs.access.script_field_default"
    test_ref: "test_entity_lifecycle.lua::ecs.access.script_field_default"
    quirks_anchor: "ecs-script-access"
    status: "verified"
    severity: "info"
    tags: ["ecs", "access", "defaults"]
    rationale: "script_field safely returns default without manual nil handling."
    example_good: |
      local health = script_field(eid, "health", 100)
    example_bad: |
      local script = safe_script_get(eid)
      local health = script and script.health or 100
    last_verified_commit: "pending"

  - rule_id: "ecs-pattern-007"
    category: "ecs-patterns"
    rule_text: "Use component_cache.get for hot paths instead of registry:get to avoid redundant lookups."
    doc_id: "pattern:ecs.cache.get_valid"
    test_ref: "test_entity_lifecycle.lua::ecs.cache.get_valid"
    quirks_anchor: "ecs-component-cache"
    status: "verified"
    severity: "info"
    tags: ["ecs", "cache", "performance"]
    rationale: "Cached lookups are O(1) after first access."
    example_good: |
      local transform = component_cache.get(eid, Transform)
    example_bad: |
      local transform = registry:get(Transform, eid)  -- always lookups
    last_verified_commit: "pending"

  - rule_id: "ecs-pattern-008"
    category: "ecs-patterns"
    rule_text: "After destroying entities, clear cached components to avoid stale reference bugs."
    doc_id: "pattern:ecs.destroy.cache_cleared"
    test_ref: "test_entity_lifecycle.lua::ecs.destroy.cache_cleared"
    quirks_anchor: "ecs-destruction"
    status: "verified"
    severity: "warn"
    tags: ["ecs", "destroy", "cache"]
    rationale: "Destruction must clear caches to avoid returning dead data."
    example_good: |
      registry:destroy(eid)
      component_cache.invalidate(eid)
    example_bad: |
      registry:destroy(eid)  -- cache still returns old transform
    last_verified_commit: "pending"

  - rule_id: "ecs-pattern-009"
    category: "ecs-patterns"
    rule_text: "On destruction, revalidate references with safe_script_get or ensure_entity before reuse."
    doc_id: "pattern:ecs.destroy.no_stale_refs"
    test_ref: "test_entity_lifecycle.lua::ecs.destroy.no_stale_refs"
    quirks_anchor: "ecs-destruction"
    status: "verified"
    severity: "warn"
    tags: ["ecs", "destroy", "validation"]
    rationale: "Always re-validate before using old ids after any destruction."
    example_good: |
      if safe_script_get(ref) == nil then
          -- reference is stale, handle accordingly
      end
    example_bad: |
      -- Assume ref is still valid after unrelated destroy
    last_verified_commit: "pending"

  - rule_id: "ecs-pattern-010"
    category: "ecs-patterns"
    rule_text: "Destroy-then-recreate should produce a clean script table with no cached garbage."
    doc_id: "pattern:ecs.destroy.then_recreate"
    test_ref: "test_entity_lifecycle.lua::ecs.destroy.then_recreate"
    quirks_anchor: "ecs-destruction"
    status: "verified"
    severity: "info"
    tags: ["ecs", "destroy", "recreation"]
    rationale: "New entity after destroy must have fresh state, not cached remnants."
    example_good: |
      destroy_entity(old_eid)
      local new = create_entity()  -- clean slate
    example_bad: |
      -- New entity somehow has old entity's cached data
    last_verified_commit: "pending"

  - rule_id: "ecs-pattern-011"
    category: "ecs-patterns"
    rule_text: "Remove invalid entity references from registries or lists after destroy to avoid stale lookups."
    doc_id: "pattern:ecs.destroy.cleanup_all_references"
    test_ref: "test_entity_lifecycle.lua::ecs.destroy.cleanup_all_references"
    quirks_anchor: "ecs-destruction"
    status: "verified"
    severity: "warn"
    tags: ["ecs", "destroy", "cleanup"]
    rationale: "Entity lists/registries must be cleaned to prevent iterating over destroyed entities."
    example_good: |
      enemy_list = filter(enemy_list, ensure_entity)
    example_bad: |
      -- enemy_list still contains destroyed entity ids
    last_verified_commit: "pending"
