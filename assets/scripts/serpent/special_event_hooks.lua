-- assets/scripts/serpent/special_event_hooks.lua
--[[
    Special Event Hooks Module

    Coordinates special ability event hooks by routing events to the appropriate
    special ability handlers. Implements the event hook phase as specified in task bd-7v3.

    Event routing:
    - enemy_dead events -> berserker frenzy (kill counter)
    - wave_start events -> paladin divine shield reset
]]

local specials_system = require("serpent.specials_system")

-- Mock log functions for environments that don't have them
local log_debug = log_debug or function(msg) end
local log_warning = log_warning or function(msg) end

local special_event_hooks = {}

--- Process a batch of enemy death events for special abilities
--- @param enemy_death_events table Array of enemy death events
--- @param ctx table Combat context with snake_state
--- @return table Array of additional events generated by special abilities
function special_event_hooks.process_enemy_death_events(enemy_death_events, ctx)
    local extra_events = {}

    if not enemy_death_events or #enemy_death_events == 0 then
        return extra_events
    end

    if not ctx then
        log_warning("[SpecialEventHooks] Nil context provided to process_enemy_death_events")
        return extra_events
    end

    log_debug(string.format("[SpecialEventHooks] Processing %d enemy death events", #enemy_death_events))

    -- Route each enemy death event to special ability handlers
    for _, death_event in ipairs(enemy_death_events) do
        if death_event and death_event.type == "DeathEventEnemy" then
            -- Route to specials system for berserker frenzy processing
            local special_events = specials_system.on_enemy_death(ctx, death_event)

            for _, event in ipairs(special_events) do
                table.insert(extra_events, event)
            end

            log_debug(string.format("[SpecialEventHooks] Enemy death event for enemy_id=%s processed",
                      tostring(death_event.enemy_id)))
        end
    end

    log_debug(string.format("[SpecialEventHooks] Generated %d extra events from enemy deaths", #extra_events))
    return extra_events
end

--- Process wave start event for special abilities
--- @param wave_num number Wave number that's starting
--- @param ctx table Combat context with snake_state
--- @return table Array of events generated (typically empty for wave start)
function special_event_hooks.process_wave_start_event(wave_num, ctx)
    local events = {}

    if not ctx then
        log_warning("[SpecialEventHooks] Nil context provided to process_wave_start_event")
        return events
    end

    log_debug(string.format("[SpecialEventHooks] Processing wave start event for wave %d", wave_num))

    -- Route to specials system for paladin shield reset
    specials_system.on_wave_start(ctx)

    log_debug("[SpecialEventHooks] Wave start event processed, paladin shields reset")
    return events
end

--- Process multiple event types in batch for special abilities
--- @param events table Mixed array of events to process
--- @param ctx table Combat context
--- @return table Array of additional events generated
function special_event_hooks.process_event_batch(events, ctx)
    local extra_events = {}

    if not events or #events == 0 then
        return extra_events
    end

    -- Separate events by type
    local enemy_death_events = {}
    local wave_start_events = {}
    local other_events = {}

    for _, event in ipairs(events) do
        if event and event.type == "DeathEventEnemy" then
            table.insert(enemy_death_events, event)
        elseif event and event.type == "WaveStartEvent" then
            table.insert(wave_start_events, event)
        else
            table.insert(other_events, event)
        end
    end

    -- Process enemy death events for berserker
    if #enemy_death_events > 0 then
        local death_extra_events = special_event_hooks.process_enemy_death_events(enemy_death_events, ctx)
        for _, event in ipairs(death_extra_events) do
            table.insert(extra_events, event)
        end
    end

    -- Process wave start events for paladin
    for _, wave_event in ipairs(wave_start_events) do
        local wave_extra_events = special_event_hooks.process_wave_start_event(wave_event.wave_num, ctx)
        for _, event in ipairs(wave_extra_events) do
            table.insert(extra_events, event)
        end
    end

    log_debug(string.format("[SpecialEventHooks] Processed %d events: %d enemy deaths, %d wave starts, %d others",
              #events, #enemy_death_events, #wave_start_events, #other_events))

    return extra_events
end

--- Get statistics about berserker kill counts
--- @param ctx table Combat context with snake_state
--- @return table Statistics about berserker units
function special_event_hooks.get_berserker_stats(ctx)
    local stats = {
        berserker_count = 0,
        total_kills = 0,
        max_kills = 0,
        berserkers = {}
    }

    if not ctx or not ctx.snake_state or not ctx.snake_state.segments then
        return stats
    end

    for _, segment in ipairs(ctx.snake_state.segments) do
        if segment and segment.special_id == "berserker_frenzy" and segment.hp and segment.hp > 0 then
            stats.berserker_count = stats.berserker_count + 1

            local kill_count = 0
            if segment.special_state and segment.special_state.kill_count then
                kill_count = segment.special_state.kill_count
            end

            stats.total_kills = stats.total_kills + kill_count
            stats.max_kills = math.max(stats.max_kills, kill_count)

            table.insert(stats.berserkers, {
                instance_id = segment.instance_id,
                kill_count = kill_count,
                attack_bonus_percent = kill_count * 5 -- 5% per kill
            })
        end
    end

    return stats
end

--- Get statistics about paladin shield states
--- @param ctx table Combat context with snake_state
--- @return table Statistics about paladin units
function special_event_hooks.get_paladin_stats(ctx)
    local stats = {
        paladin_count = 0,
        shields_available = 0,
        shields_used = 0,
        paladins = {}
    }

    if not ctx or not ctx.snake_state or not ctx.snake_state.segments then
        return stats
    end

    for _, segment in ipairs(ctx.snake_state.segments) do
        if segment and segment.special_id == "paladin_divine_shield" and segment.hp and segment.hp > 0 then
            stats.paladin_count = stats.paladin_count + 1

            local shield_used = false
            if segment.special_state and segment.special_state.shield_used then
                shield_used = segment.special_state.shield_used
            end

            if shield_used then
                stats.shields_used = stats.shields_used + 1
            else
                stats.shields_available = stats.shields_available + 1
            end

            table.insert(stats.paladins, {
                instance_id = segment.instance_id,
                shield_used = shield_used,
                shield_available = not shield_used
            })
        end
    end

    return stats
end

--- Test berserker kill credit functionality
--- @return boolean True if berserker kill credit works correctly
function special_event_hooks.test_berserker_kill_credit()
    -- Create test context with berserker
    local ctx = {
        snake_state = {
            segments = {
                {
                    instance_id = 1,
                    special_id = "berserker_frenzy",
                    hp = 100,
                    special_state = { kill_count = 0 }
                },
                {
                    instance_id = 2,
                    special_id = "knight_block",
                    hp = 150
                }
            }
        }
    }

    -- Create enemy death event
    local death_events = {
        {
            type = "DeathEventEnemy",
            enemy_id = 123,
            killed_by_instance_id = 1
        }
    }

    -- Process the events
    special_event_hooks.process_enemy_death_events(death_events, ctx)

    -- Check that berserker got kill credit
    local berserker = ctx.snake_state.segments[1]
    if berserker.special_state.kill_count ~= 1 then
        log_warning("[SpecialEventHooks] Berserker kill credit test failed")
        return false
    end

    log_debug("[SpecialEventHooks] Berserker kill credit test passed")
    return true
end

--- Test paladin shield reset functionality
--- @return boolean True if paladin shield reset works correctly
function special_event_hooks.test_paladin_shield_reset()
    -- Create test context with paladin (shield used)
    local ctx = {
        snake_state = {
            segments = {
                {
                    instance_id = 1,
                    special_id = "paladin_divine_shield",
                    hp = 150,
                    special_state = { shield_used = true }
                }
            }
        }
    }

    -- Process wave start event
    special_event_hooks.process_wave_start_event(2, ctx)

    -- Check that paladin shield was reset
    local paladin = ctx.snake_state.segments[1]
    if paladin.special_state.shield_used ~= false then
        log_warning("[SpecialEventHooks] Paladin shield reset test failed")
        return false
    end

    log_debug("[SpecialEventHooks] Paladin shield reset test passed")
    return true
end

--- Test event batch processing
--- @return boolean True if batch processing works correctly
function special_event_hooks.test_batch_processing()
    -- Create test context with both berserker and paladin
    local ctx = {
        snake_state = {
            segments = {
                {
                    instance_id = 1,
                    special_id = "berserker_frenzy",
                    hp = 100,
                    special_state = { kill_count = 2 }
                },
                {
                    instance_id = 2,
                    special_id = "paladin_divine_shield",
                    hp = 150,
                    special_state = { shield_used = true }
                }
            }
        }
    }

    -- Create mixed event batch
    local events = {
        { type = "DeathEventEnemy", enemy_id = 123 },
        { type = "WaveStartEvent", wave_num = 5 },
        { type = "DeathEventEnemy", enemy_id = 124 },
        { type = "OtherEvent", data = "ignored" }
    }

    -- Process the batch
    local extra_events = special_event_hooks.process_event_batch(events, ctx)

    -- Check results
    local berserker = ctx.snake_state.segments[1]
    local paladin = ctx.snake_state.segments[2]

    if berserker.special_state.kill_count ~= 4 then -- 2 + 2 kills
        log_warning("[SpecialEventHooks] Batch processing berserker test failed")
        return false
    end

    if paladin.special_state.shield_used ~= false then -- Should be reset
        log_warning("[SpecialEventHooks] Batch processing paladin test failed")
        return false
    end

    log_debug("[SpecialEventHooks] Batch processing test passed")
    return true
end

--- Run all special event hook tests
--- @return boolean True if all tests pass
function special_event_hooks.run_all_tests()
    local tests = {
        { "berserker_kill_credit", special_event_hooks.test_berserker_kill_credit },
        { "paladin_shield_reset", special_event_hooks.test_paladin_shield_reset },
        { "batch_processing", special_event_hooks.test_batch_processing },
    }

    local passed = 0
    local total = #tests

    log_debug("[SpecialEventHooks] Running " .. total .. " tests...")

    for _, test in ipairs(tests) do
        local test_name, test_func = test[1], test[2]
        local success = test_func()

        if success then
            log_debug("[SpecialEventHooks] ✓ " .. test_name)
            passed = passed + 1
        else
            log_warning("[SpecialEventHooks] ✗ " .. test_name)
        end
    end

    log_debug(string.format("[SpecialEventHooks] Results: %d/%d tests passed", passed, total))
    return passed == total
end

return special_event_hooks