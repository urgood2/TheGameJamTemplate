# Codex (Lua bindings & scripts)

## How Lua is wired
- C++ entrypoint `scripting::initLuaMasterState` sets `package.path` to `assets/scripts/**` (core, init, monobehavior, external) and registers hot-reload tracking per file.
- `require("registry")` returns the `entt.registry` module from `scripting/registry_bond.cpp`; global `registry` is also set to the active C++ registry. Use `entt_null` for a null entity.
- Bound APIs are documented in `assets/scripts/chugget_code_definitions.lua` (auto-generated by `BindingRecorder`) and summarized in `docs/api/lua_api_reference.md`. Regenerate definitions by letting `initLuaMasterState` run after changing bindings.
- Adding a binding: declare in `src/systems/scripting/scripting_functions.hpp`, implement in the `.cpp`, bind + record in `initLuaMasterState`, and register component types with `register_meta_component` in `scripting_system.cpp` if you want `registry:emplace/get/has/remove` support.

## Components & registry quirks
- `registry:emplace(entity, Component, tbl)` currently **ignores the Lua table** and default-constructs; set fields after `emplace` or via `registry:get`.
- `register_meta_component` is already called for ScriptComponent, Transform/InheritedProperties/GameObject/TreeOrderComponent, layer order, UI components, shader pipeline bits, GOAPComponent, particles, springs, shader uniforms, animation, and text. New component types must be added there to be usable from Lua.
- `registry:add_script(eid, lua_table)` attaches `ScriptComponent`, injecting `id`, `owner`, and `__entity_id` and caching hooks. C++ `script_system_update` is currently dormant; per-frame updates run via `Node.update_all` in Lua.
- Logging helpers `log_debug/log_error` accept an optional first argument `Entity` (number) to tag messages.

## MonoBehavior base (`assets/scripts/monobehavior/behavior_script_v2.lua`)
- Define behaviors via `local Foo = Node:extend()`; instantiate with `Foo{...}`. Initialization merges the arg table then calls `:init`.
- Call `:attach_ecs{create_new=true|false, existing_entity=eid}` after initializing fields to create/use an entity and auto-add `ScriptComponent`. Any queued `:run_custom_func(fn)` calls execute once attached.
- `Node.update_all(dt)` runs every frame from `core/main.lua`, skipping entities failing `registry.valid` or `entity_cache.active`. If you gate activity via state tags, make sure they are set before the update loop.
- `destroy_when(condition, opts)` polls via timers and destroys the entity when the condition is true; it will delete once `_eid` exists, so guard your conditions carefully.

## Game loop & caching (`assets/scripts/core/main.lua`)
- `main.update(dt)` order: `component_cache.begin_frame()` → update timers (`timer.update` + `timer.update_physics_step`) → refresh `entity_cache`/`component_cache` → `Node.update_all(dt)` → gameplay logic (skipped when paused or in main menu) → `component_cache.end_frame()`.
- `component_cache` and `entity_cache` are per-frame; do not store cached values across frames. Use `component_cache.get(eid, Component)` for tight loops instead of repeated `registry:get`. Invalidate manually with `component_cache.invalidate(eid[, Component])` if you mutate objects outside the normal flow.

## Timers & tasks
- Central timer at `assets/scripts/core/timer.lua`: `after`, `every`, `cooldown`, `every_step`, `for_time`, `tween_scalar/tracks/fields`, `run_every_render_frame`, plus physics-step hooks `on_new_physics_step`/`every_physics_step`. Tags auto-generate if omitted; use tags/groups to cancel or pause. Cancels during `timer.update` are deferred safely.
- Coroutine helpers in `assets/scripts/task/task.lua`: `task.wait(seconds)` yields with accumulated `dt`; `run_task(self, fn)` and `run_named_task(self, name, fn)` push coroutines onto the script via `get_script_component`. Requires `self.__entity_id` (set by `add_script`).

## Script/module map (assets/scripts)
- Core systems: `core/component_cache.lua`, `core/entity_cache.lua`, `core/timer.lua`, `core/timer_chain.lua`, `core/type_defs.lua` (Board layout helper), `core/entity_factory.lua`, `core/gameplay.lua` (states `PLANNING_STATE`, `ACTION_STATE`, `SHOP_STATE`, etc.), `core/globals.lua` (shared game data), `core/shader_uniforms.lua`.
- Mono behaviors: `monobehavior/behavior_script_v2.lua` (base), helpers in `task/`, `init/bit_compat.lua` for LuaJIT bit ops, `core/type_defs.lua` for card/board behavior.
- UI: DSL + helpers in `ui/ui_syntax_sugar.lua`, `ui/ui_definition_helper.lua`, `ui/ui_defs.lua`; layer ordering via `core/z_orders.lua` and `layer_order_system` bindings.
- Utilities: `util/util.lua` (e.g., `getScriptTableFromEntityID`, camera pan helpers, particle spawners), easing, palette, wand/card DSL under `wand/` and `core/card_eval_order_test.lua`.
- External libs live under `assets/scripts/external` (lume, hump.signal/gamestate, object.lua class helper, etc.).

## Telemetry & events
- Lua telemetry is a thin shim (`telemetry.record(name, props_table?)`, `telemetry.session_id()`) and is safe to call even when disabled; backing sink is PostHog with config/env gating (`telemetry.cpp`).
- Lua/Cpp events are bound in `event_system` (`subscribeToCppEvent`, `publishLuaEvent`, etc.) with signatures documented in `chugget_code_definitions.lua`.

## Hot reload & packaging
- `lua_hot_reload::track` watches loaded script paths; `safe_script_file` is used for loading to preserve error context. Globals set at load time will rerun on reload—guard long-lived tables (e.g., `_G.component_cache`) with `if _G.foo then return _G.foo end` patterns like in the caches.
- `assets/scripts/scripting_config.json` defines which directories to preload (`core`, `monobehavior`, `tutorial`, `task`).

## Common pitfalls / tips
- Always validate entities (`entity_cache.valid` or `registry:valid`) before touching components; C++ warns on invalid handles.
- Because `registry:emplace` ignores Lua data, configure components after emplacing. For data-driven components, prefer helper builders or post-emplace setters.
- `Node.update_all` skips inactive entities; ensure state tags or `is_entity_active` return true for things that must tick.
- Do not hold onto component references across frames; caches reset each frame. Re-fetch via `component_cache.get` inside updates.
- Timer tags must be unique per logical timer to avoid overwrites; use stringified IDs (`"foo_" .. eid`) like existing code.
- `destroy_when` destroys once `_eid` exists regardless of validity checks in `do_destroy`; wrap conditions defensively.
- For new bindings, use `BindingRecorder` helpers (`rec.bind_function`, `rec.record_method`) so `chugget_code_definitions.lua` stays accurate.

## Quick references
- Bindings: `src/systems/scripting/scripting_functions.cpp`, `src/systems/scripting/scripting_system.cpp`.
- Definitions output: `assets/scripts/chugget_code_definitions.lua`.
- Runtime loop: `assets/scripts/core/main.lua`.
- Reference doc: `docs/api/lua_api_reference.md`.
